{"ast":null,"code":"/**\n * @fileOverview\n * @author Brandon Alexander - baalexander@gmail.com\n */\n\nvar WebSocket = require('ws');\nvar WorkerSocket = require('../util/workerSocket');\nvar socketAdapter = require('./SocketAdapter.js');\nvar Service = require('./Service');\nvar ServiceRequest = require('./ServiceRequest');\nvar assign = require('object-assign');\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n * Manages connection to the server and all interactions with ROS.\n *\n * Emits the following events:\n *  * 'error' - There was an error with ROS.\n *  * 'connection' - Connected to the WebSocket server.\n *  * 'close' - Disconnected to the WebSocket server.\n *  * &#60;topicName&#62; - A message came from rosbridge with the given topic name.\n *  * &#60;serviceID&#62; - A service response came from rosbridge with the given ID.\n *\n * @constructor\n * @param {Object} options\n * @param {string} [options.url] - The WebSocket URL for rosbridge or the node server URL to connect using socket.io (if socket.io exists in the page). Can be specified later with `connect`.\n * @param {boolean} [options.groovyCompatibility=true] - Don't use interfaces that changed after the last groovy release or rosbridge_suite and related tools.\n * @param {string} [options.transportLibrary=websocket] - One of 'websocket', 'workersocket', 'socket.io' or RTCPeerConnection instance controlling how the connection is created in `connect`.\n * @param {Object} [options.transportOptions={}] - The options to use when creating a connection. Currently only used if `transportLibrary` is RTCPeerConnection.\n */\nfunction Ros(options) {\n  options = options || {};\n  var that = this;\n  this.socket = null;\n  this.idCounter = 0;\n  this.isConnected = false;\n  this.transportLibrary = options.transportLibrary || 'websocket';\n  this.transportOptions = options.transportOptions || {};\n  this._sendFunc = function (msg) {\n    that.sendEncodedMessage(msg);\n  };\n  if (typeof options.groovyCompatibility === 'undefined') {\n    this.groovyCompatibility = true;\n  } else {\n    this.groovyCompatibility = options.groovyCompatibility;\n  }\n\n  // Sets unlimited event listeners.\n  this.setMaxListeners(0);\n\n  // begin by checking if a URL was given\n  if (options.url) {\n    this.connect(options.url);\n  }\n}\nRos.prototype.__proto__ = EventEmitter2.prototype;\n\n/**\n * Connect to the specified WebSocket.\n *\n * @param {string} url - WebSocket URL or RTCDataChannel label for rosbridge.\n */\nRos.prototype.connect = function (url) {\n  if (this.transportLibrary === 'socket.io') {\n    this.socket = assign(io(url, {\n      'force new connection': true\n    }), socketAdapter(this));\n    this.socket.on('connect', this.socket.onopen);\n    this.socket.on('data', this.socket.onmessage);\n    this.socket.on('close', this.socket.onclose);\n    this.socket.on('error', this.socket.onerror);\n  } else if (this.transportLibrary.constructor.name === 'RTCPeerConnection') {\n    this.socket = assign(this.transportLibrary.createDataChannel(url, this.transportOptions), socketAdapter(this));\n  } else if (this.transportLibrary === 'websocket') {\n    if (!this.socket || this.socket.readyState === WebSocket.CLOSED) {\n      var sock = new WebSocket(url);\n      sock.binaryType = 'arraybuffer';\n      this.socket = assign(sock, socketAdapter(this));\n    }\n  } else if (this.transportLibrary === 'workersocket') {\n    this.socket = assign(new WorkerSocket(url), socketAdapter(this));\n  } else {\n    throw 'Unknown transportLibrary: ' + this.transportLibrary.toString();\n  }\n};\n\n/**\n * Disconnect from the WebSocket server.\n */\nRos.prototype.close = function () {\n  if (this.socket) {\n    this.socket.close();\n  }\n};\n\n/**\n * Send an authorization request to the server.\n *\n * @param {string} mac - MAC (hash) string given by the trusted source.\n * @param {string} client - IP of the client.\n * @param {string} dest - IP of the destination.\n * @param {string} rand - Random string given by the trusted source.\n * @param {Object} t - Time of the authorization request.\n * @param {string} level - User level as a string given by the client.\n * @param {Object} end - End time of the client's session.\n */\nRos.prototype.authenticate = function (mac, client, dest, rand, t, level, end) {\n  // create the request\n  var auth = {\n    op: 'auth',\n    mac: mac,\n    client: client,\n    dest: dest,\n    rand: rand,\n    t: t,\n    level: level,\n    end: end\n  };\n  // send the request\n  this.callOnConnection(auth);\n};\n\n/**\n * Send an encoded message over the WebSocket.\n *\n * @param {Object} messageEncoded - The encoded message to be sent.\n */\nRos.prototype.sendEncodedMessage = function (messageEncoded) {\n  var emitter = null;\n  var that = this;\n  if (this.transportLibrary === 'socket.io') {\n    emitter = function (msg) {\n      that.socket.emit('operation', msg);\n    };\n  } else {\n    emitter = function (msg) {\n      that.socket.send(msg);\n    };\n  }\n  if (!this.isConnected) {\n    that.once('connection', function () {\n      emitter(messageEncoded);\n    });\n  } else {\n    emitter(messageEncoded);\n  }\n};\n\n/**\n * Send the message over the WebSocket, but queue the message up if not yet\n * connected.\n *\n * @param {Object} message - The message to be sent.\n */\nRos.prototype.callOnConnection = function (message) {\n  if (this.transportOptions.encoder) {\n    this.transportOptions.encoder(message, this._sendFunc);\n  } else {\n    this._sendFunc(JSON.stringify(message));\n  }\n};\n\n/**\n * Send a set_level request to the server.\n *\n * @param {string} level - Status level (none, error, warning, info).\n * @param {number} [id] - Operation ID to change status level on.\n */\nRos.prototype.setStatusLevel = function (level, id) {\n  var levelMsg = {\n    op: 'set_level',\n    level: level,\n    id: id\n  };\n  this.callOnConnection(levelMsg);\n};\n\n/**\n * Retrieve a list of action servers in ROS as an array of string.\n *\n * @param {function} callback - Function with the following params:\n * @param {string[]} callback.actionservers - Array of action server names.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getActionServers = function (callback, failedCallback) {\n  var getActionServers = new Service({\n    ros: this,\n    name: '/rosapi/action_servers',\n    serviceType: 'rosapi/GetActionServers'\n  });\n  var request = new ServiceRequest({});\n  if (typeof failedCallback === 'function') {\n    getActionServers.callService(request, function (result) {\n      callback(result.action_servers);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    getActionServers.callService(request, function (result) {\n      callback(result.action_servers);\n    });\n  }\n};\n\n/**\n * Retrieve a list of topics in ROS as an array.\n *\n * @param {function} callback - Function with the following params:\n * @param {Object} callback.result - The result object with the following params:\n * @param {string[]} callback.result.topics - Array of topic names.\n * @param {string[]} callback.result.types - Array of message type names.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getTopics = function (callback, failedCallback) {\n  var topicsClient = new Service({\n    ros: this,\n    name: '/rosapi/topics',\n    serviceType: 'rosapi/Topics'\n  });\n  var request = new ServiceRequest();\n  if (typeof failedCallback === 'function') {\n    topicsClient.callService(request, function (result) {\n      callback(result);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    topicsClient.callService(request, function (result) {\n      callback(result);\n    });\n  }\n};\n\n/**\n * Retrieve a list of topics in ROS as an array of a specific type.\n *\n * @param {string} topicType - The topic type to find.\n * @param {function} callback - Function with the following params:\n * @param {string[]} callback.topics - Array of topic names.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getTopicsForType = function (topicType, callback, failedCallback) {\n  var topicsForTypeClient = new Service({\n    ros: this,\n    name: '/rosapi/topics_for_type',\n    serviceType: 'rosapi/TopicsForType'\n  });\n  var request = new ServiceRequest({\n    type: topicType\n  });\n  if (typeof failedCallback === 'function') {\n    topicsForTypeClient.callService(request, function (result) {\n      callback(result.topics);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    topicsForTypeClient.callService(request, function (result) {\n      callback(result.topics);\n    });\n  }\n};\n\n/**\n * Retrieve a list of active service names in ROS.\n *\n * @param {function} callback - Function with the following params:\n * @param {string[]} callback.services - Array of service names.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getServices = function (callback, failedCallback) {\n  var servicesClient = new Service({\n    ros: this,\n    name: '/rosapi/services',\n    serviceType: 'rosapi/Services'\n  });\n  var request = new ServiceRequest();\n  if (typeof failedCallback === 'function') {\n    servicesClient.callService(request, function (result) {\n      callback(result.services);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    servicesClient.callService(request, function (result) {\n      callback(result.services);\n    });\n  }\n};\n\n/**\n * Retrieve a list of services in ROS as an array as specific type.\n *\n * @param {string} serviceType - The service type to find.\n * @param {function} callback - Function with the following params:\n * @param {string[]} callback.topics - Array of service names.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getServicesForType = function (serviceType, callback, failedCallback) {\n  var servicesForTypeClient = new Service({\n    ros: this,\n    name: '/rosapi/services_for_type',\n    serviceType: 'rosapi/ServicesForType'\n  });\n  var request = new ServiceRequest({\n    type: serviceType\n  });\n  if (typeof failedCallback === 'function') {\n    servicesForTypeClient.callService(request, function (result) {\n      callback(result.services);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    servicesForTypeClient.callService(request, function (result) {\n      callback(result.services);\n    });\n  }\n};\n\n/**\n * Retrieve the details of a ROS service request.\n *\n * @param {string} type - The type of the service.\n * @param {function} callback - Function with the following params:\n * @param {Object} callback.result - The result object with the following params:\n * @param {string[]} callback.result.typedefs - An array containing the details of the service request.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getServiceRequestDetails = function (type, callback, failedCallback) {\n  var serviceTypeClient = new Service({\n    ros: this,\n    name: '/rosapi/service_request_details',\n    serviceType: 'rosapi/ServiceRequestDetails'\n  });\n  var request = new ServiceRequest({\n    type: type\n  });\n  if (typeof failedCallback === 'function') {\n    serviceTypeClient.callService(request, function (result) {\n      callback(result);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    serviceTypeClient.callService(request, function (result) {\n      callback(result);\n    });\n  }\n};\n\n/**\n * Retrieve the details of a ROS service response.\n *\n * @param {string} type - The type of the service.\n * @param {function} callback - Function with the following params:\n * @param {Object} callback.result - The result object with the following params:\n * @param {string[]} callback.result.typedefs - An array containing the details of the service response.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getServiceResponseDetails = function (type, callback, failedCallback) {\n  var serviceTypeClient = new Service({\n    ros: this,\n    name: '/rosapi/service_response_details',\n    serviceType: 'rosapi/ServiceResponseDetails'\n  });\n  var request = new ServiceRequest({\n    type: type\n  });\n  if (typeof failedCallback === 'function') {\n    serviceTypeClient.callService(request, function (result) {\n      callback(result);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    serviceTypeClient.callService(request, function (result) {\n      callback(result);\n    });\n  }\n};\n\n/**\n * Retrieve a list of active node names in ROS.\n *\n * @param {function} callback - Function with the following params:\n * @param {string[]} callback.nodes - Array of node names.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getNodes = function (callback, failedCallback) {\n  var nodesClient = new Service({\n    ros: this,\n    name: '/rosapi/nodes',\n    serviceType: 'rosapi/Nodes'\n  });\n  var request = new ServiceRequest();\n  if (typeof failedCallback === 'function') {\n    nodesClient.callService(request, function (result) {\n      callback(result.nodes);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    nodesClient.callService(request, function (result) {\n      callback(result.nodes);\n    });\n  }\n};\n\n/**\n * Retrieve a list of subscribed topics, publishing topics and services of a specific node.\n * <br>\n * These are the parameters if failedCallback is <strong>defined</strong>.\n *\n * @param {string} node - Name of the node.\n * @param {function} callback - Function with the following params:\n * @param {string[]} callback.subscriptions - Array of subscribed topic names.\n * @param {string[]} callback.publications - Array of published topic names.\n * @param {string[]} callback.services - Array of service names hosted.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n *\n * @also\n *\n * Retrieve a list of subscribed topics, publishing topics and services of a specific node.\n * <br>\n * These are the parameters if failedCallback is <strong>undefined</strong>.\n *\n * @param {string} node - Name of the node.\n * @param {function} callback - Function with the following params:\n * @param {Object} callback.result - The result object with the following params:\n * @param {string[]} callback.result.subscribing - Array of subscribed topic names.\n * @param {string[]} callback.result.publishing - Array of published topic names.\n * @param {string[]} callback.result.services - Array of service names hosted.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getNodeDetails = function (node, callback, failedCallback) {\n  var nodesClient = new Service({\n    ros: this,\n    name: '/rosapi/node_details',\n    serviceType: 'rosapi/NodeDetails'\n  });\n  var request = new ServiceRequest({\n    node: node\n  });\n  if (typeof failedCallback === 'function') {\n    nodesClient.callService(request, function (result) {\n      callback(result.subscribing, result.publishing, result.services);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    nodesClient.callService(request, function (result) {\n      callback(result);\n    });\n  }\n};\n\n/**\n * Retrieve a list of parameter names from the ROS Parameter Server.\n *\n * @param {function} callback - Function with the following params:\n * @param {string[]} callback.params - Array of param names.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getParams = function (callback, failedCallback) {\n  var paramsClient = new Service({\n    ros: this,\n    name: '/rosapi/get_param_names',\n    serviceType: 'rosapi/GetParamNames'\n  });\n  var request = new ServiceRequest();\n  if (typeof failedCallback === 'function') {\n    paramsClient.callService(request, function (result) {\n      callback(result.names);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    paramsClient.callService(request, function (result) {\n      callback(result.names);\n    });\n  }\n};\n\n/**\n * Retrieve the type of a ROS topic.\n *\n * @param {string} topic - Name of the topic.\n * @param {function} callback - Function with the following params:\n * @param {string} callback.type - The type of the topic.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getTopicType = function (topic, callback, failedCallback) {\n  var topicTypeClient = new Service({\n    ros: this,\n    name: '/rosapi/topic_type',\n    serviceType: 'rosapi/TopicType'\n  });\n  var request = new ServiceRequest({\n    topic: topic\n  });\n  if (typeof failedCallback === 'function') {\n    topicTypeClient.callService(request, function (result) {\n      callback(result.type);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    topicTypeClient.callService(request, function (result) {\n      callback(result.type);\n    });\n  }\n};\n\n/**\n * Retrieve the type of a ROS service.\n *\n * @param {string} service - Name of the service.\n * @param {function} callback - Function with the following params:\n * @param {string} callback.type - The type of the service.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getServiceType = function (service, callback, failedCallback) {\n  var serviceTypeClient = new Service({\n    ros: this,\n    name: '/rosapi/service_type',\n    serviceType: 'rosapi/ServiceType'\n  });\n  var request = new ServiceRequest({\n    service: service\n  });\n  if (typeof failedCallback === 'function') {\n    serviceTypeClient.callService(request, function (result) {\n      callback(result.type);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    serviceTypeClient.callService(request, function (result) {\n      callback(result.type);\n    });\n  }\n};\n\n/**\n * Retrieve the details of a ROS message.\n *\n * @param {string} message - The name of the message type.\n * @param {function} callback - Function with the following params:\n * @param {string} callback.details - An array of the message details.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getMessageDetails = function (message, callback, failedCallback) {\n  var messageDetailClient = new Service({\n    ros: this,\n    name: '/rosapi/message_details',\n    serviceType: 'rosapi/MessageDetails'\n  });\n  var request = new ServiceRequest({\n    type: message\n  });\n  if (typeof failedCallback === 'function') {\n    messageDetailClient.callService(request, function (result) {\n      callback(result.typedefs);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    messageDetailClient.callService(request, function (result) {\n      callback(result.typedefs);\n    });\n  }\n};\n\n/**\n * Decode a typedef array into a dictionary like `rosmsg show foo/bar`.\n *\n * @param {Object[]} defs - Array of type_def dictionary.\n */\nRos.prototype.decodeTypeDefs = function (defs) {\n  var that = this;\n  var decodeTypeDefsRec = function (theType, hints) {\n    // calls itself recursively to resolve type definition using hints.\n    var typeDefDict = {};\n    for (var i = 0; i < theType.fieldnames.length; i++) {\n      var arrayLen = theType.fieldarraylen[i];\n      var fieldName = theType.fieldnames[i];\n      var fieldType = theType.fieldtypes[i];\n      if (fieldType.indexOf('/') === -1) {\n        // check the fieldType includes '/' or not\n        if (arrayLen === -1) {\n          typeDefDict[fieldName] = fieldType;\n        } else {\n          typeDefDict[fieldName] = [fieldType];\n        }\n      } else {\n        // lookup the name\n        var sub = false;\n        for (var j = 0; j < hints.length; j++) {\n          if (hints[j].type.toString() === fieldType.toString()) {\n            sub = hints[j];\n            break;\n          }\n        }\n        if (sub) {\n          var subResult = decodeTypeDefsRec(sub, hints);\n          if (arrayLen === -1) {\n            typeDefDict[fieldName] = subResult; // add this decoding result to dictionary\n          } else {\n            typeDefDict[fieldName] = [subResult];\n          }\n        } else {\n          that.emit('error', 'Cannot find ' + fieldType + ' in decodeTypeDefs');\n        }\n      }\n    }\n    return typeDefDict;\n  };\n  return decodeTypeDefsRec(defs[0], defs);\n};\n\n/**\n * Retrieve a list of topics and their associated type definitions.\n *\n * @param {function} callback - Function with the following params:\n * @param {Object} callback.result - The result object with the following params:\n * @param {string[]} callback.result.topics - Array of topic names.\n * @param {string[]} callback.result.types - Array of message type names.\n * @param {string[]} callback.result.typedefs_full_text - Array of full definitions of message types, similar to `gendeps --cat`.\n * @param {function} [failedCallback] - The callback function when the service call failed with params:\n * @param {string} failedCallback.error - The error message reported by ROS.\n */\nRos.prototype.getTopicsAndRawTypes = function (callback, failedCallback) {\n  var topicsAndRawTypesClient = new Service({\n    ros: this,\n    name: '/rosapi/topics_and_raw_types',\n    serviceType: 'rosapi/TopicsAndRawTypes'\n  });\n  var request = new ServiceRequest();\n  if (typeof failedCallback === 'function') {\n    topicsAndRawTypesClient.callService(request, function (result) {\n      callback(result);\n    }, function (message) {\n      failedCallback(message);\n    });\n  } else {\n    topicsAndRawTypesClient.callService(request, function (result) {\n      callback(result);\n    });\n  }\n};\nmodule.exports = Ros;","map":null,"metadata":{},"sourceType":"script"}