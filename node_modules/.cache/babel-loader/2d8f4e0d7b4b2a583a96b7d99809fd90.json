{"ast":null,"code":"/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;\n!function (undefined) {\n  var hasOwnProperty = Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported = typeof process == 'object' && typeof process.nextTick == 'function';\n  var symbolsSupported = typeof Symbol === 'function';\n  var reflectSupported = typeof Reflect === 'object';\n  var setImmediateSupported = typeof setImmediate === 'function';\n  var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;\n  var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === 'function' ? Reflect.ownKeys : function (obj) {\n    var arr = Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  } : Object.keys;\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      if (conf.maxListeners !== undefined) {\n        this._maxListeners = conf.maxListeners;\n      }\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' + 'leak detected. ' + count + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.';\n    if (this.verboseMemoryLeak) {\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n    if (typeof process !== 'undefined' && process.emitWarning) {\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n      if (console.trace) {\n        console.trace();\n      }\n    }\n  }\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? values.length : 0;\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n    return obj;\n  }\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n    var on, off;\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n    this._on = on;\n    this._off = off;\n    var _observers = emitter._observers;\n    if (_observers) {\n      _observers.push(this);\n    } else {\n      emitter._observers = [this];\n    }\n  }\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function (event, localEvent, reducer) {\n      var observer = this;\n      var target = this._target;\n      var emitter = this._emitter;\n      var listeners = this._listeners;\n      var handler = function () {\n        var args = toArray.apply(null, arguments);\n        var eventObj = {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n        if (reducer) {\n          var result = reducer.call(target, eventObj);\n          if (result !== false) {\n            emitter.emit.apply(emitter, [eventObj.name].concat(args));\n          }\n          return;\n        }\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n      if (listeners[event]) {\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n      this._listenersCount++;\n      if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n            observer._on.call(target, event, handler);\n          }\n        };\n        emitter.on('newListener', this._onNewListener);\n        this._onRemoveListener = function (_event) {\n          if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {\n            listeners[event] = null;\n            observer._off.call(target, event, handler);\n          }\n        };\n        listeners[event] = null;\n        emitter.on('removeListener', this._onRemoveListener);\n      } else {\n        listeners[event] = handler;\n        observer._on.call(target, event, handler);\n      }\n    },\n    unsubscribe: function (event) {\n      var observer = this;\n      var listeners = this._listeners;\n      var emitter = this._emitter;\n      var handler;\n      var events;\n      var off = this._off;\n      var target = this._target;\n      var i;\n      if (event && typeof event !== 'string') {\n        throw TypeError('event must be a string');\n      }\n      function clearRefs() {\n        if (observer._onNewListener) {\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener = null;\n          observer._onRemoveListener = null;\n        }\n        var index = findTargetIndex.call(emitter, observer);\n        emitter._observers.splice(index, 1);\n      }\n      if (event) {\n        handler = listeners[event];\n        if (!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n        if (! --this._listenersCount) {\n          clearRefs();\n        }\n      } else {\n        events = ownKeys(listeners);\n        i = events.length;\n        while (i-- > 0) {\n          event = events[i];\n          off.call(target, event, listeners[event]);\n        }\n        this._listeners = {};\n        this._listenersCount = 0;\n        clearRefs();\n      }\n    }\n  });\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n    if (!options) return computedOptions;\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''));\n    }\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n    return value;\n  }\n  function makeTypeReducer(types) {\n    var message = 'value must be type of ' + types.join('|');\n    var len = types.length;\n    var firstType = types[0];\n    var secondType = types[1];\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n        reject(message);\n      };\n    }\n    if (len === 2) {\n      return function (v, reject) {\n        var kind = typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      };\n    }\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n      reject(message);\n    };\n  }\n  var functionReducer = makeTypeReducer(['function']);\n  var objectFunctionReducer = makeTypeReducer(['object', 'function']);\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer = 0;\n    var subscriptionClosed;\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options = resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function (value, reject) {\n          value *= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n      var _resolve = function (value) {\n        cleanup();\n        resolve(value);\n      };\n      var _reject = function (err) {\n        cleanup();\n        reject(err);\n      };\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function (reason) {\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously');\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscriptionClosed = true;\n      }\n      if (options.timeout > 0) {\n        timer = setTimeout(function () {\n          var reason = Error('timeout');\n          reason.code = 'ETIMEDOUT';\n          timer = 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n    return promise;\n  }\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n    if (!observers) {\n      return -1;\n    }\n    var len = observers.length;\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n    return -1;\n  }\n\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n    if (i === 0) {\n      var kind = typeof type;\n      if (kind === 'string') {\n        var ns,\n          n,\n          l = 0,\n          j = 0,\n          delimiter = this.delimiter,\n          dl = delimiter.length;\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n    var listeners = null,\n      branch,\n      xTree,\n      xxTree,\n      isolatedBranch,\n      endReached,\n      currentType = type[i],\n      nextType = type[i + 1],\n      branches,\n      _listeners;\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n\n      if (tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        branches = ownKeys(xxTree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {\n                '**': isolatedBranch\n              }, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n    return listeners;\n  }\n  function growListenerTree(type, listener, prepend) {\n    var len = 0,\n      j = 0,\n      i,\n      delimiter = this.delimiter,\n      dl = delimiter.length,\n      ns;\n    if (typeof type === 'string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n        ns[len++] = type.slice(j);\n      } else {\n        ns = [type];\n        len = 1;\n      }\n    } else {\n      ns = type;\n      len = type.length;\n    }\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n    var tree = this.listenerTree,\n      name;\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n      tree = tree[name] || (tree[name] = {});\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n          if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n    }\n    return true;\n  }\n  function collectTreeEvents(tree, events, root, asArray) {\n    var branches = ownKeys(tree);\n    var i = branches.length;\n    var branch, branchName, path;\n    var hasListeners = tree['_listeners'];\n    var isArrayPath;\n    while (i-- > 0) {\n      branchName = branches[i];\n      branch = tree[branchName];\n      if (branchName === '_listeners') {\n        path = root;\n      } else {\n        path = root ? root.concat(branchName) : [branchName];\n      }\n      isArrayPath = asArray || typeof branchName === 'symbol';\n      hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));\n      if (typeof branch === 'object') {\n        collectTreeEvents.call(this, branch, events, path, isArrayPath);\n      }\n    }\n    return events;\n  }\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i = keys.length;\n    var obj, key, flag;\n    while (i-- > 0) {\n      key = keys[i];\n      obj = root[key];\n      if (obj) {\n        flag = true;\n        if (key !== '_listeners' && !recursivelyGarbageCollect(obj)) {\n          delete root[key];\n        }\n      }\n    }\n    return flag;\n  }\n  function Listener(emitter, event, listener) {\n    this.emitter = emitter;\n    this.event = event;\n    this.listener = listener;\n  }\n  Listener.prototype.off = function () {\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n  function setupListener(event, listener, options) {\n    if (options === true) {\n      promisify = true;\n    } else if (options === false) {\n      async = true;\n    } else {\n      if (!options || typeof options !== 'object') {\n        throw TypeError('options should be an object or true');\n      }\n      var async = options.async;\n      var promisify = options.promisify;\n      var nextTick = options.nextTick;\n      var objectify = options.objectify;\n    }\n    if (async || nextTick || promisify) {\n      var _listener = listener;\n      var _origin = listener._origin || listener;\n      if (nextTick && !nextTickSupported) {\n        throw Error('process.nextTick is not supported');\n      }\n      if (promisify === undefined) {\n        promisify = listener.constructor.name === 'AsyncFunction';\n      }\n      listener = function () {\n        var args = arguments;\n        var context = this;\n        var event = this.event;\n        return promisify ? nextTick ? Promise.resolve() : new Promise(function (resolve) {\n          _setImmediate(resolve);\n        }).then(function () {\n          context.event = event;\n          return _listener.apply(context, args);\n        }) : (nextTick ? process.nextTick : _setImmediate)(function () {\n          context.event = event;\n          _listener.apply(context, args);\n        });\n      };\n      listener._async = true;\n      listener._origin = _origin;\n    }\n    return [listener, objectify ? new Listener(this, event, listener) : this];\n  }\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo = function (target, events, options) {\n    if (typeof target !== 'object') {\n      throw TypeError('target musts be an object');\n    }\n    var emitter = this;\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n    function listen(events) {\n      if (typeof events !== 'object') {\n        throw TypeError('events must be an object');\n      }\n      var reducers = options.reducers;\n      var index = findTargetIndex.call(emitter, target);\n      var observer;\n      if (index === -1) {\n        observer = new TargetObserver(emitter, target, options);\n      } else {\n        observer = emitter._observers[index];\n      }\n      var keys = ownKeys(events);\n      var len = keys.length;\n      var event;\n      var isSingleReducer = typeof reducers === 'function';\n      for (var i = 0; i < len; i++) {\n        event = keys[i];\n        observer.subscribe(event, events[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);\n      }\n    }\n    isArray(events) ? listen(toObject(events)) : typeof events === 'string' ? listen(toObject(events.split(/\\s+/))) : listen(events);\n    return this;\n  };\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n    if (!observers) {\n      return false;\n    }\n    var i = observers.length;\n    var observer;\n    var matched = false;\n    if (target && typeof target !== 'object') {\n      throw TypeError('target should be an object');\n    }\n    while (i-- > 0) {\n      observer = observers[i];\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched = true;\n      }\n    }\n    return matched;\n  };\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n  EventEmitter.prototype.setMaxListeners = function (n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n  EventEmitter.prototype.getMaxListeners = function () {\n    return this._maxListeners;\n  };\n  EventEmitter.prototype.event = '';\n  EventEmitter.prototype.once = function (event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n  EventEmitter.prototype.prependOnceListener = function (event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n  EventEmitter.prototype._once = function (event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n  EventEmitter.prototype.many = function (event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n  EventEmitter.prototype.prependMany = function (event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n  EventEmitter.prototype._many = function (event, ttl, fn, prepend, options) {\n    var self = this;\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n    listener._origin = fn;\n    return this._on(event, listener, prepend, options);\n  };\n  EventEmitter.prototype.emit = function () {\n    if (!this._events && !this._all) {\n      return false;\n    }\n    this._events || init.call(this);\n    var type = arguments[0],\n      ns,\n      wildcard = this.wildcard;\n    var args, l, i, j, containsSymbol;\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n    if (wildcard) {\n      ns = type;\n      if (type !== 'newListener' && type !== 'removeListener') {\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n    var al = arguments.length;\n    var handler;\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            handler[i].call(this, type);\n            break;\n          case 2:\n            handler[i].call(this, type, arguments[1]);\n            break;\n          case 3:\n            handler[i].call(this, type, arguments[1], arguments[2]);\n            break;\n          default:\n            handler[i].apply(this, arguments);\n        }\n      }\n    }\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n          case 1:\n            handler.call(this);\n            break;\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          default:\n            args = new Array(al - 1);\n            for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n            handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            handler[i].call(this);\n            break;\n          case 2:\n            handler[i].call(this, arguments[1]);\n            break;\n          case 3:\n            handler[i].call(this, arguments[1], arguments[2]);\n            break;\n          default:\n            handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n    return !!this._all;\n  };\n  EventEmitter.prototype.emitAsync = function () {\n    if (!this._events && !this._all) {\n      return false;\n    }\n    this._events || init.call(this);\n    var type = arguments[0],\n      wildcard = this.wildcard,\n      ns,\n      containsSymbol;\n    var args, l, i, j;\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return Promise.resolve([false]);\n      }\n    }\n    if (wildcard) {\n      ns = type;\n      if (type !== 'newListener' && type !== 'removeListener') {\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n    var promises = [];\n    var al = arguments.length;\n    var handler;\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            promises.push(this._all[i].call(this, type));\n            break;\n          case 2:\n            promises.push(this._all[i].call(this, type, arguments[1]));\n            break;\n          case 3:\n            promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n            break;\n          default:\n            promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n        case 1:\n          promises.push(handler.call(this));\n          break;\n        case 2:\n          promises.push(handler.call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler.call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n          case 1:\n            promises.push(handler[i].call(this));\n            break;\n          case 2:\n            promises.push(handler[i].call(this, arguments[1]));\n            break;\n          case 3:\n            promises.push(handler[i].call(this, arguments[1], arguments[2]));\n            break;\n          default:\n            promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n    return Promise.all(promises);\n  };\n  EventEmitter.prototype.on = function (type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n  EventEmitter.prototype.prependListener = function (type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n  EventEmitter.prototype.onAny = function (fn) {\n    return this._onAny(fn, false);\n  };\n  EventEmitter.prototype.prependAny = function (fn) {\n    return this._onAny(fn, true);\n  };\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n  EventEmitter.prototype._onAny = function (fn, prepend) {\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if (prepend) {\n      this._all.unshift(fn);\n    } else {\n      this._all.push(fn);\n    }\n    return this;\n  };\n  EventEmitter.prototype._on = function (type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n    var returnValue = this,\n      temp;\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    }\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if (prepend) {\n        this._events[type].unshift(listener);\n      } else {\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n    return returnValue;\n  };\n  EventEmitter.prototype.off = function (type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n    var handlers,\n      leafs = [];\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if (!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({\n        _listeners: handlers\n      });\n    }\n    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n        var position = -1;\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {\n            position = i;\n            break;\n          }\n        }\n        if (position < 0) {\n          continue;\n        }\n        if (this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        } else {\n          this._events[type].splice(position, 1);\n        }\n        if (handlers.length === 0) {\n          if (this.wildcard) {\n            delete leaf._listeners;\n          } else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener) this.emit(\"removeListener\", type, listener);\n        return this;\n      } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {\n        if (this.wildcard) {\n          delete leaf._listeners;\n        } else {\n          delete this._events[type];\n        }\n        if (this._removeListener) this.emit(\"removeListener\", type, listener);\n      }\n    }\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    return this;\n  };\n  EventEmitter.prototype.offAny = function (fn) {\n    var i = 0,\n      l = 0,\n      fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for (i = 0, l = fns.length; i < l; i++) {\n        if (fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener) this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for (i = 0, l = fns.length; i < l; i++) this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0),\n        leaf,\n        i;\n      if (!leafs) return this;\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n      if (!_events) {\n        return [];\n      }\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree = this.listenerTree;\n        if (!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n      if (!_events) {\n        return [];\n      }\n      listeners = _events[type];\n      if (!listeners) {\n        return [];\n      }\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n  EventEmitter.prototype.eventNames = function (nsAsArray) {\n    var _events = this._events;\n    return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];\n  };\n  EventEmitter.prototype.listenerCount = function (type) {\n    return this.listeners(type).length;\n  };\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n    var _events = this._events;\n    var _all = this._all;\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n  EventEmitter.prototype.listenersAny = function () {\n    if (this._all) {\n      return this._all;\n    } else {\n      return [];\n    }\n  };\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {\n        timeout: options\n      };\n    } else if (type === 'function') {\n      options = {\n        filter: options\n      };\n    }\n    options = resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter = options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        self.off(event, listener);\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n      onCancel(function () {\n        self.off(event, listener);\n      });\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  };\n  function once(emitter, name, options) {\n    options = resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n    var _Promise = options.Promise;\n    return makeCancelablePromise(_Promise, function (resolve, reject, onCancel) {\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler = function () {\n          resolve(toArray.apply(null, arguments));\n        };\n        onCancel(function () {\n          emitter.removeEventListener(name, handler);\n        });\n        emitter.addEventListener(name, handler, {\n          once: true\n        });\n        return;\n      }\n      var eventListener = function () {\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n      var errorListener;\n      if (name !== 'error') {\n        errorListener = function (err) {\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n        emitter.once('error', errorListener);\n      }\n      onCancel(function () {\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n  var prototype = EventEmitter.prototype;\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number');\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(prototype, {\n    _maxListeners: {\n      value: defaultMaxListeners,\n      writable: true,\n      configurable: true\n    },\n    _observers: {\n      value: null,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  } else {\n    // global for any kind of environment.\n    var _global = new Function('', 'return this')();\n    _global.EventEmitter2 = EventEmitter;\n  }\n}();","map":null,"metadata":{},"sourceType":"script"}