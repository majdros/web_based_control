{"ast":null,"code":"/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Patrick Gansterer <paroga@paroga.com>\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\n\n(function (global, undefined) {\n  \"use strict\";\n\n  var POW_2_24 = Math.pow(2, -24),\n    POW_2_32 = Math.pow(2, 32),\n    POW_2_53 = Math.pow(2, 53);\n  function encode(value) {\n    var data = new ArrayBuffer(256);\n    var dataView = new DataView(data);\n    var lastLength;\n    var offset = 0;\n    function ensureSpace(length) {\n      var newByteLength = data.byteLength;\n      var requiredLength = offset + length;\n      while (newByteLength < requiredLength) newByteLength *= 2;\n      if (newByteLength !== data.byteLength) {\n        var oldDataView = dataView;\n        data = new ArrayBuffer(newByteLength);\n        dataView = new DataView(data);\n        var uint32count = offset + 3 >> 2;\n        for (var i = 0; i < uint32count; ++i) dataView.setUint32(i * 4, oldDataView.getUint32(i * 4));\n      }\n      lastLength = length;\n      return dataView;\n    }\n    function write() {\n      offset += lastLength;\n    }\n    function writeFloat64(value) {\n      write(ensureSpace(8).setFloat64(offset, value));\n    }\n    function writeUint8(value) {\n      write(ensureSpace(1).setUint8(offset, value));\n    }\n    function writeUint8Array(value) {\n      var dataView = ensureSpace(value.length);\n      for (var i = 0; i < value.length; ++i) dataView.setUint8(offset + i, value[i]);\n      write();\n    }\n    function writeUint16(value) {\n      write(ensureSpace(2).setUint16(offset, value));\n    }\n    function writeUint32(value) {\n      write(ensureSpace(4).setUint32(offset, value));\n    }\n    function writeUint64(value) {\n      var low = value % POW_2_32;\n      var high = (value - low) / POW_2_32;\n      var dataView = ensureSpace(8);\n      dataView.setUint32(offset, high);\n      dataView.setUint32(offset + 4, low);\n      write();\n    }\n    function writeTypeAndLength(type, length) {\n      if (length < 24) {\n        writeUint8(type << 5 | length);\n      } else if (length < 0x100) {\n        writeUint8(type << 5 | 24);\n        writeUint8(length);\n      } else if (length < 0x10000) {\n        writeUint8(type << 5 | 25);\n        writeUint16(length);\n      } else if (length < 0x100000000) {\n        writeUint8(type << 5 | 26);\n        writeUint32(length);\n      } else {\n        writeUint8(type << 5 | 27);\n        writeUint64(length);\n      }\n    }\n    function encodeItem(value) {\n      var i;\n      if (value === false) return writeUint8(0xf4);\n      if (value === true) return writeUint8(0xf5);\n      if (value === null) return writeUint8(0xf6);\n      if (value === undefined) return writeUint8(0xf7);\n      switch (typeof value) {\n        case \"number\":\n          if (Math.floor(value) === value) {\n            if (0 <= value && value <= POW_2_53) return writeTypeAndLength(0, value);\n            if (-POW_2_53 <= value && value < 0) return writeTypeAndLength(1, -(value + 1));\n          }\n          writeUint8(0xfb);\n          return writeFloat64(value);\n        case \"string\":\n          var utf8data = [];\n          for (i = 0; i < value.length; ++i) {\n            var charCode = value.charCodeAt(i);\n            if (charCode < 0x80) {\n              utf8data.push(charCode);\n            } else if (charCode < 0x800) {\n              utf8data.push(0xc0 | charCode >> 6);\n              utf8data.push(0x80 | charCode & 0x3f);\n            } else if (charCode < 0xd800) {\n              utf8data.push(0xe0 | charCode >> 12);\n              utf8data.push(0x80 | charCode >> 6 & 0x3f);\n              utf8data.push(0x80 | charCode & 0x3f);\n            } else {\n              charCode = (charCode & 0x3ff) << 10;\n              charCode |= value.charCodeAt(++i) & 0x3ff;\n              charCode += 0x10000;\n              utf8data.push(0xf0 | charCode >> 18);\n              utf8data.push(0x80 | charCode >> 12 & 0x3f);\n              utf8data.push(0x80 | charCode >> 6 & 0x3f);\n              utf8data.push(0x80 | charCode & 0x3f);\n            }\n          }\n          writeTypeAndLength(3, utf8data.length);\n          return writeUint8Array(utf8data);\n        default:\n          var length;\n          if (Array.isArray(value)) {\n            length = value.length;\n            writeTypeAndLength(4, length);\n            for (i = 0; i < length; ++i) encodeItem(value[i]);\n          } else if (value instanceof Uint8Array) {\n            writeTypeAndLength(2, value.length);\n            writeUint8Array(value);\n          } else {\n            var keys = Object.keys(value);\n            length = keys.length;\n            writeTypeAndLength(5, length);\n            for (i = 0; i < length; ++i) {\n              var key = keys[i];\n              encodeItem(key);\n              encodeItem(value[key]);\n            }\n          }\n      }\n    }\n    encodeItem(value);\n    if (\"slice\" in data) return data.slice(0, offset);\n    var ret = new ArrayBuffer(offset);\n    var retView = new DataView(ret);\n    for (var i = 0; i < offset; ++i) retView.setUint8(i, dataView.getUint8(i));\n    return ret;\n  }\n  function decode(data, tagger, simpleValue) {\n    var dataView = new DataView(data);\n    var offset = 0;\n    if (typeof tagger !== \"function\") tagger = function (value) {\n      return value;\n    };\n    if (typeof simpleValue !== \"function\") simpleValue = function () {\n      return undefined;\n    };\n    function read(value, length) {\n      offset += length;\n      return value;\n    }\n    function readArrayBuffer(length) {\n      return read(new Uint8Array(data, offset, length), length);\n    }\n    function readFloat16() {\n      var tempArrayBuffer = new ArrayBuffer(4);\n      var tempDataView = new DataView(tempArrayBuffer);\n      var value = readUint16();\n      var sign = value & 0x8000;\n      var exponent = value & 0x7c00;\n      var fraction = value & 0x03ff;\n      if (exponent === 0x7c00) exponent = 0xff << 10;else if (exponent !== 0) exponent += 127 - 15 << 10;else if (fraction !== 0) return fraction * POW_2_24;\n      tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);\n      return tempDataView.getFloat32(0);\n    }\n    function readFloat32() {\n      return read(dataView.getFloat32(offset), 4);\n    }\n    function readFloat64() {\n      return read(dataView.getFloat64(offset), 8);\n    }\n    function readUint8() {\n      return read(dataView.getUint8(offset), 1);\n    }\n    function readUint16() {\n      return read(dataView.getUint16(offset), 2);\n    }\n    function readUint32() {\n      return read(dataView.getUint32(offset), 4);\n    }\n    function readUint64() {\n      return readUint32() * POW_2_32 + readUint32();\n    }\n    function readBreak() {\n      if (dataView.getUint8(offset) !== 0xff) return false;\n      offset += 1;\n      return true;\n    }\n    function readLength(additionalInformation) {\n      if (additionalInformation < 24) return additionalInformation;\n      if (additionalInformation === 24) return readUint8();\n      if (additionalInformation === 25) return readUint16();\n      if (additionalInformation === 26) return readUint32();\n      if (additionalInformation === 27) return readUint64();\n      if (additionalInformation === 31) return -1;\n      throw \"Invalid length encoding\";\n    }\n    function readIndefiniteStringLength(majorType) {\n      var initialByte = readUint8();\n      if (initialByte === 0xff) return -1;\n      var length = readLength(initialByte & 0x1f);\n      if (length < 0 || initialByte >> 5 !== majorType) throw \"Invalid indefinite length element\";\n      return length;\n    }\n    function appendUtf16data(utf16data, length) {\n      for (var i = 0; i < length; ++i) {\n        var value = readUint8();\n        if (value & 0x80) {\n          if (value < 0xe0) {\n            value = (value & 0x1f) << 6 | readUint8() & 0x3f;\n            length -= 1;\n          } else if (value < 0xf0) {\n            value = (value & 0x0f) << 12 | (readUint8() & 0x3f) << 6 | readUint8() & 0x3f;\n            length -= 2;\n          } else {\n            value = (value & 0x0f) << 18 | (readUint8() & 0x3f) << 12 | (readUint8() & 0x3f) << 6 | readUint8() & 0x3f;\n            length -= 3;\n          }\n        }\n        if (value < 0x10000) {\n          utf16data.push(value);\n        } else {\n          value -= 0x10000;\n          utf16data.push(0xd800 | value >> 10);\n          utf16data.push(0xdc00 | value & 0x3ff);\n        }\n      }\n    }\n    function decodeItem() {\n      var initialByte = readUint8();\n      var majorType = initialByte >> 5;\n      var additionalInformation = initialByte & 0x1f;\n      var i;\n      var length;\n      if (majorType === 7) {\n        switch (additionalInformation) {\n          case 25:\n            return readFloat16();\n          case 26:\n            return readFloat32();\n          case 27:\n            return readFloat64();\n        }\n      }\n      length = readLength(additionalInformation);\n      if (length < 0 && (majorType < 2 || 6 < majorType)) throw \"Invalid length\";\n      switch (majorType) {\n        case 0:\n          return length;\n        case 1:\n          return -1 - length;\n        case 2:\n          if (length < 0) {\n            var elements = [];\n            var fullArrayLength = 0;\n            while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n              fullArrayLength += length;\n              elements.push(readArrayBuffer(length));\n            }\n            var fullArray = new Uint8Array(fullArrayLength);\n            var fullArrayOffset = 0;\n            for (i = 0; i < elements.length; ++i) {\n              fullArray.set(elements[i], fullArrayOffset);\n              fullArrayOffset += elements[i].length;\n            }\n            return fullArray;\n          }\n          return readArrayBuffer(length);\n        case 3:\n          var utf16data = [];\n          if (length < 0) {\n            while ((length = readIndefiniteStringLength(majorType)) >= 0) appendUtf16data(utf16data, length);\n          } else appendUtf16data(utf16data, length);\n          return String.fromCharCode.apply(null, utf16data);\n        case 4:\n          var retArray;\n          if (length < 0) {\n            retArray = [];\n            while (!readBreak()) retArray.push(decodeItem());\n          } else {\n            retArray = new Array(length);\n            for (i = 0; i < length; ++i) retArray[i] = decodeItem();\n          }\n          return retArray;\n        case 5:\n          var retObject = {};\n          for (i = 0; i < length || length < 0 && !readBreak(); ++i) {\n            var key = decodeItem();\n            retObject[key] = decodeItem();\n          }\n          return retObject;\n        case 6:\n          return tagger(decodeItem(), length);\n        case 7:\n          switch (length) {\n            case 20:\n              return false;\n            case 21:\n              return true;\n            case 22:\n              return null;\n            case 23:\n              return undefined;\n            default:\n              return simpleValue(length);\n          }\n      }\n    }\n    var ret = decodeItem();\n    if (offset !== data.byteLength) throw \"Remaining bytes\";\n    return ret;\n  }\n  var obj = {\n    encode: encode,\n    decode: decode\n  };\n  if (typeof define === \"function\" && define.amd) define(\"cbor/cbor\", obj);else if (typeof module !== 'undefined' && module.exports) module.exports = obj;else if (!global.CBOR) global.CBOR = obj;\n})(this);","map":null,"metadata":{},"sourceType":"script"}