{"ast":null,"code":"'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\nvar warnedPrecision = false;\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n\n/**\n * Unpack 64-bit unsigned integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n  return arr;\n}\n\n/**\n * Unpack 64-bit signed integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n  return arr;\n}\n\n/**\n * Unpack typed array from byte array.\n * @param {Uint8Array} bytes\n * @param {type} ArrayType - Desired output array type\n*/\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n\n/**\n * Supports a subset of draft CBOR typed array tags:\n *     <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\n *\n * Only supports little-endian tags for now.\n */\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n\n/**\n * We can also decode 64-bit integer arrays, since ROS has these types.\n */\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n\n/**\n * Handle CBOR typed array tags during decoding.\n * @param {Uint8Array} data\n * @param {Number} tag\n */\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n  return data;\n}\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}","map":null,"metadata":{},"sourceType":"script"}